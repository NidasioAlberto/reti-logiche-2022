Il componente è organizzato tramite una macchina a stati che scandisce gli accessi alla memoria e le fasi di elaborazione. All'avvio e dopo ogni reset, la macchina rimane in attesa del segnale \verb|i_start| e, dopo averlo ricevuto, recupera la dimensione $W$ del flusso $U$ e successivamente esegue in sequenza la lettura di un byte $U_k$, il calcolo dei due byte derivanti da $U_k$ e la loro scrittura in memoria. Questo ciclo si conclude quando tutti i $W$ byte sono stati elaborati.

\subsection{Macchina a stati}

La macchina a stati sintetizzata, mostrata in figura \ref{fig:statemachine}, è composta da i seguenti 9 stati:

\begin{itemize}
    \item \textbf{IDLE}: La macchina è in attesa del segnale \verb|i_start| e rimane in questo stato finché il segnale non viene portato a $1$;
    \item \textbf{REQUEST\_W} e \textbf{FETCH\_W}: Viene attivata la memoria indicando l'indirizzo di lettura $0$ di $W$. L'output viene quindi letto da \verb|i_data| e memorizzato, sarà poi utilizzato per contare i cicli di computazione;
    \item \textbf{REQUEST\_U} e \textbf{FETCH\_U}: Viene utilizzata la memoria ancora in modalità lettura per recuperare un byte del flusso $U$, come indirizzo viene utilizzato il numero del ciclo corrente;
    \item \textbf{COMPUTE\_P}: In questa fase vengono calcolati due byte del flusso in uscita a partire dal byte precedentemente letto, vedi sezione \ref{section:calcolodiz};
    \item \textbf{WRITE\_P1} e \textbf{WRITE\_P2}: Vengono scritti in memoria i due byte del flusso $Z$ calcolati precedentemente. Se sono stati elaborati tutti i $W$ byte del flusso $U$, la macchina passa nello stato \textbf{DONE} portando a $1$ il segnale \verb|o_done|, altrimenti continua ripartendo da \textbf{REQUEST\_U};
    \item \textbf{DONE}: La computazione è terminata e viene atteso il reset del segnale \verb|i_start| per riportare a zero \verb|o_done| e tornare nello stato di \textbf{IDLE}.
\end{itemize}

\tikzstyle{statenode} = [state, minimum size=12mm, text width=11mm, align=center]

\begin{figure}[!ht]
    \centering
    \begin{tikzpicture}[node distance=4cm]
        \node(idle)    at (0,   0) [statenode, initial]   {\textbf{idle}};
        \node(reqw)    at (4,   0) [statenode]            {\textbf{req. $W$}};
        \node(fetchw)  at (7,   0) [statenode]            {\textbf{fetch $W$}};
        \node(requ)    at (10,  0) [statenode]            {\textbf{req. $U_k$}};
        \node(fetchu)  at (10, -3) [statenode]            {\textbf{fetch $U_k$}};
        \node(compp)   at (7,  -3) [statenode]            {\textbf{comp. $Z_k$}};
        \node(writep1) at (4,  -3) [statenode]            {\textbf{write $Z_{1k}$}};
        \node(writep2) at (1,  -3) [statenode]            {\textbf{write $Z_{2k}$}};
        \node(done)    at (-2, -3) [statenode, accepting] {\textbf{done}};

        \path[->] (idle) edge[loop above] node {i\_start = 0} (idle);
        \draw[->] (idle) edge[above] node {i\_start = 1} (reqw);
        \draw[->] (reqw) -- (fetchw);
        \draw[->] (fetchw) -- (requ);
        \draw[->] (requ) -- (fetchu);
        \draw[->] (fetchu) -- (compp);
        \draw[->] (compp) -- (writep1);
        \draw[->] (writep1) -- (writep2);
        \draw[->] (writep2) edge[above] node {k != W} (requ);
        \draw[->] (writep2) edge[above] node {k = W}  (done);
    \end{tikzpicture}
    \caption{Macchina a stati del componente implementato}
    \label{fig:statemachine}
\end{figure}

\subsection{Calcolo del flusso \texorpdfstring{$Z$}{}}
\label{section:calcolodiz}

Il convolutore descritto in sezione \ref{section:convolutore} potrebbe essere implementato tramite la macchina a stati illustrata nelle specifiche del progetto \footcite{specifichedelprogetto}, avendo quindi 4 stati e calcolando, ad ogni step, i bit $P_{1k}$ e $P_{2k}$. In questo modo ci vorrebbero 8 cicli di clock per concludere l'elaborazione di un byte letto da memoria.

Considerando la dimensione di indirizzamento, è stato utilizzato un approccio differente per il calcolo di $P$ che permette di elaborare un byte del flusso $U$ in un singolo ciclo di clock.

All'interno del componente viene mantenuto un buffer composto da un vettore di 10 elementi in grado di memorizzare il byte in ingresso e gli ultimi due bit del byte letto durante lo step precedente. Questo ci permette di eseguire le equazioni \ref{eq:p1k} e \ref{eq:p2k} su ciascuno degli 8 bit letti in un ciclo solo. Come mostrato in figura \ref{code:calcolop}, in VHDL questo viene ottenuto tramite un ciclo \verb|for| che elabora il byte in ingesso e produce i due byte del flusso in uscita $P$.

Il risultato è un componente che riesce ad elaborare ciascun byte letto dalla memoria in un singolo ciclo di clock, riducendo così il tempo che il convolutore impiega per elaborare il flusso in ingresso $U$. Il vantaggio in termini di tempo viene ottenuto a discapito delle risorse hardware utilizzare, infatti vengono sintetizzate le eq. \ref{eq:p1k} e \ref{eq:p2k} per 8 volte.

\begin{figure}[!ht]
    \centering
    \begin{varwidth}{\linewidth}
        \begin{verbatim}
-- Compute the 1/2 convolutional code
for k in 7 downto 0 loop
    -- Compute P1k and P2k
    next_P(k * 2 + 1) <= conv_state(k + 2) xor conv_state(k);
    next_P(k * 2)     <= conv_state(k + 2) xor conv_state(k + 1)
                                           xor conv_state(k);
end loop;
    \end{verbatim}
    \end{varwidth}
    \caption{Calcolo di due byte del flusso $K$}
    \label{code:calcolop}
\end{figure}

\subsection{Architettura del componente}

Il componente descritto in VHDL è organizzato in due processi separati.

Il primo rimane in ascolto dei segnali \verb|i_rst| e \verb|i_clk|. Nel caso il segnale di reset venga alzato, lo stato viene resettato immediatamente riportando lo stato ad \verb|IDLE| e resettato il buffer utilizzato per il calcolo di $P$. In caso contrario, si avanza allo stato successivo aggiornando i registri.

Il secondo processo si occupa invece di eseguire le operazioni rispetto allo stato corrente e si attiva ogni qual volta esso viene aggiornato oppure il segnale \verb|i_start| cambia valore. In quest'ultimo caso, se il segnale è alto e lo stato corrente è \textbf{IDLE}, la macchina si avvia passando allo stato successivo, altrimenti permane nello stato in cui si trova.

All'interno dell'architettura vengono inoltre usati diversi registri: \verb|current_state|, \verb|U_count|, \verb|U_buffer| e \verb|P_buffer|. Per gestire i loro valori nel passaggio da uno stato all'altro, è stato definito un segnale ausiliario per ciascuno di essi. Questi segnali vengono modificati dalle operazioni di ciascuno stato e poi sostituiti alle loro controparti nel momento in cui lo stato viene aggiornato a causa del clock.